                                             ASSIGNMENT:1B
main.sh
book="phone_book.txt"
echo "==========================================="
echo "::Choose Any 1 of the following::
1. ADD CONTACT
2.VIEW CONTACT
3. UPDATE CONTACT
4. DELETE CONTACT
5. EXIT"
echo "==========================================="
read -r choice
echo "==========================================="
a=1 b=2 c=3 d=4 e=5
if [ $choice -eq $a ];
then
echo -n "Enter Name:: "
read name
 Department of Information Technology Page 24 of 125
echo -n "Enter Number::"
read number echo "==========================================="
echo "$name :: $number"» $book
echo "Contact Saved!"
echo "==========================================="
sh main.sh
echo "==========================================="
elif [ $choice -eq $b ]; then
echo "==========================================="
echo "::Content of $book is::"
echo "==========================================="
cat -n $book
echo "==========================================="
sh main.sh
echo "==========================================="
 Department of Information Technology Page 25 of 125
elif [ $choice -eq $c ]; then
echo "==========================================="
cat -n phone_book.txt
echo "==========================================="
echo "Which contact you want to change::"
echo "ENTER Current NAME::" read name echo "ENTER Current NUMBER::"
read number echo "==========================================="
echo "ENTER New NAME::"
read n_name
echo "ENTER New NUMBER::"
read n_number
sed -i ’s/’$name’/’$n_name’/g’ phonebook.txt
sed -i ’s/’$number’/’$n_number’/g’ phonebook.txt
echo "==========================================="
echo "Updated List::" cat phone_book.txt
echo "==========================================="
sh main.sh
echo "==========================================="
elif [ $choice -eq $d ]; then
echo "==========================================="
 Department of Information Technology Page 26 of 125
echo "Enter the Name which you want to delete::"
read name
grep -v $name $book > temp.txt cp temp.txt $book
echo "==========================================="
cat $book
echo "==========================================="
sh main.sh
echo "==========================================="
elif [ $choice -eq $e ]; then
break else
echo "==========================================="
echo "You have Entered a Wrong Choice! Try Again!"
echo "==========================================="
sh main.sh
echo "==========================================="
fi

                                     ASSIGNMENT:1A

#read command which takes the input from the keyboard
echo "What is your name?"
read PERSON
echo "Hello, $PERSON"
Output
What is your name?
Priti
Hello, Priti
#Variables are defined as follows
VAR1="SCOE Pune"
VAR2=100
echo $VAR1
echo $VAR2
SCOE Pune
100
#Array Values
NAME[0]="Vineel"
NAME[1]="Zara"
NAME[2]="Amit"
NAME[3]="Shri"
NAME[4]="Diya"
echo "First Index: ${NAME[0]}"
echo "Second Index: ${NAME[1]}"
First Index: Vineel
Second Index: Zara
#all the items in an array
 Department of Information Technology Page 19 of 125
NAME[0]="Vineel"
NAME[1]="Zara"
NAME[2]="Amit"
NAME[3]="Shri"
NAME[4]="Diya"
echo "First Method: ${NAME[*]}"
echo "Second Method: ${NAME[@]}"
First Method: Vineel Zara Amit Shri Diya
Second Method: Vineel Zara Amit Shri Diya
#Arithmetic Operators
val=`expr 2 + 2`
echo "Total value : $val"
Total value : 4
#if else program
choice=-8
if [ $choice -gt 0 ]; then
echo "$choice number is positive"
else
echo "$choice number is negative"
fi
-8 number is negative
#nested if else
echo "1. Unix (Sun Os)"
echo "2. Linux (Red Hat)"
echo -n "Select your os choice [1 or 2]? "
read osch
#osch=1
if [ $osch -eq 1 ] ; then
echo "You Pick up Unix (Sun Os)"
else
if [ $osch -eq 2 ] ; then
echo "You Pick up Linux (Red Hat)"
else
echo "What you don't like Unix/Linux OS."
fi
fi
 Department of Information Technology Page 20 of 125
1. Unix (Sun Os)
2. Linux (Red Hat)
Select your os choice [1 or 2]? 2
You Pick up Linux (Red Hat)
# for loop program
for i in 1 2 3 4 5
do
echo "Welcome $i times"
done
Welcome 1 times
Welcome 2 times
Welcome 3 times
Welcome 4 times
Welcome 5 times
# while loop program
# nested while loop program
a=0
while [ "$a" -lt 10 ] # this is loop1
do
 b="$a"
 while [ "$b" -ge 0 ] # this is loop2
 do
 echo -n "$b "
 b=`expr $b - 1`
 done
 echo
 a=`expr $a + 1`
done
0
1 0
2 1 0
3 2 1 0
4 3 2 1 0
5 4 3 2 1 0
6 5 4 3 2 1 0
7 6 5 4 3 2 1 0
8 7 6 5 4 3 2 1 0
9 8 7 6 5 4 3 2 1 0
 Department of Information Technology Page 21 of 125
# nested for loop
for var1 in 1 2 3
do
 for var2 in 0 5
 do
 if [ $var1 -eq 2 -a $var2 -eq 0 ]
 then
 break 2
 else
 echo "$var1 $var2"
 fi
 done
done
1 0
1 5
# array with loop
NUMS="1 2 3 4 5 6 7"
for NUM in $NUMS
do
 Q=`expr $NUM % 2`
 if [ $Q -eq 0 ]
 then
 echo "Number is an even number!!"
 continue
 fi
 echo "Found odd number"
done
Found odd number
Number is an even number!!
Found odd number
Number is an even number!!
Found odd number
Number is an even number!!
Found odd number
 Department of Information Technology Page 22 of 125
# function
Hello ()
{
 echo "Hello World"
}
Hello
Hello World
# function program
today()
{
 echo "Today is `date`"
 return
}
today
Today is Thu 25 2021 07:57:14 PM UTC
# Calling one function from another
number_one ()
{
 echo "This is the first function speaking..."
 number_two
}
number_two ()
{
 echo "This is now the second function speaking..."
}
# Calling function one.
number_one
This is the first function speaking...
This is now the second function speaking...
                                         ASSIGNMENT:2B
 
#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
void bsearch(int a[10], int search);
int main(int argc,char *argv[])
{
int a[11],i,n=10,search,first, last, middle,flag=0;
FILE *f;
f=fopen(argv[1],"r");
printf(" %s",argv[1]);
fscanf(f,"%d",&search);
printf(" Key=%d\n",search);
for(i=0;i<n;i++)
{
fscanf(f," %d",&a[i]);
printf(" %d",a[i]);
}
first=0;
last=n-1;
middle=(first+last)/2;
while(first<=last)
{
if(a[middle]<search){
first= middle+1;
middle=(first+last)/2;
}
else if(a[middle]==search)
{
printf("\n%d Element found at location %d \n", search, middle+1);
flag=1;
break;
}
else
{
last=middle-1;
middle=(first+last)/2;
}
}
if(flag==0)
printf("\n Not found");
return(0);
}
void bsearch(int a[11], int search)
{
int i, first, last, middle, n=10;
first=0;
last=n-1;
middle=(first+last)/2;
while(first<=last)
{
if(a[middle]<search)
first= middle+1;
else if(a[middle]==search)
{
printf("%d Element found at location %d \n", search, middle+1);
break;
}
else
{
last=middle-1;
middle=(first+last)/2;
}
if(first>last)
{
printf("Element not found %d is not present in the list\n", search);
//return 0;
}
}
}
//for main:
#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
void sort(int a[10]);
int main(int argc,char *argv[])
{
int pid;
int i=0,n=10,search;
char *env[]={NULL};
int a[11];
char *newarg[]={NULL,"sort.txt", NULL};
newarg[0]=argv[1];
printf("Enter array elements : ");
for(i=1;i<=10;i++)
scanf(" %d",&a[i]);
printf("Enter value to find : ");
scanf("%d", &search);
FILE *f;
pid=fork();
if(pid==0)
{
sleep(1);
execve(argv[1],newarg,env);
}
else
{
sort(a);
f=fopen("sort.txt","w");
fprintf(f," %d",search);
for(i=1;i<=n;i++)
{
fprintf(f," %d",a[i]);
}
}
fclose(f);
}
void sort(int a[10])
{
int n=10, i=0, j=0, temp;
for(i=1; i<=n; i++)
{
for(j=1; j<n; j++)
{
if(a[i]<a[j])
{
temp=a[i];
a[i]=a[j];
a[j]=temp;
}
}
}
}

                                            ASSINGMENT:2A
# include<stdio.h>
# include <stdlib.h>
# include<sys/types.h>
# include<unistd.h>
 int split ( int[], int , int );
 void quickSort(int* ,int, int);

 void mergeSort(int arr[],int low,int mid,int high)
 {
 int i,j,k,l,b[20];
 l=low;
 i=low;
 j=mid+1;
 while((l<=mid)&&(j<=high)){
 if(arr[l]<=arr[j]){
 b[i]=arr[l];
 l++;
 }
 else{
 b[i]=arr[j];
 j++;
 }
 i++;
 }
 if(l>mid){
 for(k=j;k<=high;k++){
 b[i]=arr[k];
 i++;
 }
 }
 else{
 for(k=l;k<=mid;k++){
 b[i]=arr[k];
 i++;
 }
 }
 for(k=low;k<=high;k++)
 {
 arr[k]=b[k];
 }
}
void partition(int arr[],int low,int high)
{
 int mid;
 if(low<high)
 {
 double temp;
 mid=(low+high)/2;
 partition(arr,low,mid);
 partition(arr,mid+1,high);
 mergeSort(arr,low,mid,high);
 }
}
 void display(int a[],int size){
 int i;
 for(i=0;i<size;i++){
 printf("%d\t\t",a[i]);
 }
 printf("\n");
 }
 int main()
 {
 int pid, child_pid;
 int size,i,status;

 /* Input the Integers to be sorted */
 printf("Enter the number of Integers to Sort::::\t");
 scanf("%d",&size);

 int a[size];
 int pArr[size];
 int cArr[size];
 for(i=0;i<size;i++){
 printf("Enter number %d:",(i+1));
 scanf("%d",&a[i]);
 pArr[i]=a[i];
 cArr[i]=a[i];
 }


 /* Display the Enterd Integers */
 printf("Your Entered Integers for Sorting\n");
 display(a,size);

 /* Process ID of the Parent */
 pid=getpid();
 printf("Current Process ID is : %d\n",pid);
 /* Child Process Creation */
 printf("[ Forking Child Process ... ] \n");
 child_pid=fork(); /* This will Create Child Process and
 Returns Child's PID */
 if( child_pid < 0){
 /* Process Creation Failed ... */

 printf("\nChild Process Creation Failed!!!!\n");
 exit(-1);
 }
 else if( child_pid==0) {
 /* Child Process */
 printf("\nThe Child Process\n");
 printf("\nchild process is %d",getpid());
 printf("\nparent of child process is %d",getppid());
 printf("Child is sorting the list of Integers by QUICK SORT::\n");
 quickSort(cArr,0,size-1);
 printf("The sorted List by Child::\n");
 display(cArr,size);
 printf("Child Process Completed ...\n");
 sleep(10);
 printf("\nparent of child process is %d",getppid());
 }
 else {
 /* Parent Process */
 printf("parent process %d started\n",getpid());
 printf("Parent of parent is %d\n",getppid());
 sleep(30);
 printf("The Parent Process\n");
 printf("Parent %d is sorting the list of Integers by MERGE SORT\n",pid);
 partition(pArr,0,size-1);
 printf("The sorted List by Parent::\n");
 display(pArr,size);
 // wait(&status);
 printf("Parent Process Completed ...\n");
 }
 return 0;
}
int split ( int a[ ], int lower, int upper )
{
 int i, p, q, t ;
 p = lower + 1 ;
 q = upper ;
 i = a[lower] ;
 while ( q >= p )
 {
 while ( a[p] < i )
 p++ ;
 while ( a[q] > i )
 q-- ;
 if ( q > p )
 {
 t = a[p] ;
 a[p] = a[q] ;
 a[q] = t ;
 }
 }
 t = a[lower] ;
 a[lower] = a[q] ;
 a[q] = t ;
 return q ;
}
void quickSort(int a[],int lower, int upper){
 int i ;
 if ( upper > lower )
 {
 i = split ( a, lower, upper ) ;
 quickSort ( a, lower, i - 1 ) ;
 quickSort ( a, i + 1, upper ) ;
 }
}                                              

                                                    ASSIGNMENT:3

#include<stdio.h>
struct process
{
int id;
int arv;
int burst;
int exc;
int prio;
int flag;
};
int d[20],s[20];
struct process temp[20];
void accept(struct process p[20],int n)
{
int i;
for(i=0;i<n;i++)
{
p[i].id=i+1;
printf("\n\tfor process p[%d]",i+1);
printf("\n\tenter arrival time:");
scanf("%d",&p[i].arv);
printf("\n\tenter burst time:");
scanf("%d",&p[i].burst);
printf("\n\tenter priority:");
scanf("%d",&p[i].prio);
p[i].flag=0;
p[i].exc=0;
}
}
void sort(struct process temp[20],int n)
{
int i,j;
struct process t;
for(i=0;i<n-1;i++)
{
for(j=0;j<n-1-i;j++)
{
if(temp[j].arv>temp[j+1].arv)
{
t=temp[j];
temp[j]=temp[j+1];
temp[j+1]=t;
}
}
}
}
void display(int n)
{
int i;
printf("\n\t");
for(i=0;i<n-1;i++)
{
printf("|\tP%d\t",s[i]);
}
printf("|\n\t");
for(i=0;i<n;i++)
{
printf("%d\t\t",d[i]);
}
}
void cal(struct process a[20],int n)
{
int i,time=0,tawt;
float awt,tat;
for(i=0;i<n;i++)
{
time=time+a[i].exc-a[i].arv;
}
tawt=time;
awt=(float)(time)/n;
time=0;
for(i=0;i<n;i++)
{
time=time+a[i].burst;
}
tat=(float)(tawt+time)/n;
printf("\n\n\taverage waiting time=%.2f",awt);
printf("\n\n\taverage turnaround time=%.2f",tat);
}
int time_comp(struct process temp[20],struct process a[20],int n)
{
int i,k=0;
for(i=0;i<n;i++)
{
if(temp[i].arv==0)
{
a[k]=temp[i];
k++;
}
}
return k;
}
void sjf_p(struct process p[20],int n)
{
int i,j,t,min,time=0,var,in=0,cnt=0;
for(i=0;i<n;i++)
temp[i]=p[i];
sort(temp,n);
for(i=0;i<n;i++)
{
min=99;
for(j=0;j<=i;j++)
{
if(min>temp[j].burst && temp[j].flag==0)
{
min=temp[j].burst;
t=j;
}
}
if(i<n-1)
{
var=temp[i+1].arv-temp[i].arv;
temp[t].exc=temp[t].burst-var;
temp[t].burst=temp[t].burst-var;
time=temp[i+1].arv;
}
else
{
var=temp[i].arv;
time=var+temp[t].burst;
temp[t].burst=temp[t].exc=0;
}
d[in]=temp[i].arv;
s[in]=temp[t].id;
in++;
if(temp[t].exc<0)
{
temp[t].exc=temp[t].burst=0;
}
if(temp[t].burst<=0)
{
p[temp[t].id-1].exc=time-p[t].burst;
temp[t].flag=1;
}
}
do
{
min=99;
for(i=0;i<n;i++)
{
if(min>temp[i].burst && temp[i].flag==0 && temp[i].burst>0)
{
min=temp[i].burst;
t=i;
}
}
temp[t].exc=0;
temp[t].flag=1;
d[in]=time;
s[in]=temp[t].id;
in++;
time=time+temp[t].burst;
p[temp[t].id-1].exc=time-p[t].burst;
temp[t].burst=0;
cnt=0;
for(i=0;i<n;i++)
{
if(temp[i].flag==1)
cnt++;
}
}while(cnt!=n);
d[in]=time;
in++;
display(in);
cal(p,n);
}
void round_r(struct process p[20],int n)
{
int i,cnt,ts,time=0,in=0;
printf("\n\temter timeslice:");
scanf("%d",&ts);
for(i=0;i<n;i++)
{
temp[i]=p[i];
}
do
{
for(i=0;i<n;i++)
{
if(temp[i].burst>0)
{
if(temp[i].burst>=ts)
{
temp[i].exc=temp[i].burst-ts;
}
else
{
temp[i].exc=temp[i].burst;
}
d[in]=time;
s[in]=temp[i].id;
in++;
if(temp[i].burst>=ts)
{
time=time+ts;
}
else
{
time=time+temp[i].burst;
}
temp[i].burst=temp[i].burst-ts;
if(temp[i].burst<=0)
{
p[temp[i].id-1].exc=time-p[i].burst;
}
}
}
cnt=0;
for(i=0;i<n;i++)
{
if(temp[i].burst<=0)
cnt++;
}
}while(cnt!=n);
d[in]=time;
in++;
display(in);
cal(p,n);
}
int main()
{
int ch,n;
struct process p[20];
do
{
printf("\n\n\t**MENU**");
printf("\n\t1.Accept");
 printf("\n\t2.Shortest Job First [Premptive]");
 printf("\n\t3.Round Robin");
 printf("\n\t0.Exit");

 printf("\n\tEnter Your Choice :");
 scanf("%d",&ch);
 switch(ch)
{
case 1:
 printf("\n\tEnter no.of processes:");
scanf("%d",&n);
accept(p,n);
break;

case 2:
 printf("\n\tSJF Preemptive:\n");
sjf_p(p,n);
break;

case 3:
 printf("\n\tRound Robin:\n");
round_r(p,n);
break;
}
}while(ch!=0);
return 0;
}
     

                          ASSIGNMENT:4A
#include <pthread.h>
#include <semaphore.h>
#include <stdlib.h>
#include <stdio.h>
/*
This program provides a possible solution for producer-consumer problem
using mutex and semaphore.
I have used 5 producers and 5 consumers to demonstrate the solution. You
can always play with these values.
*/
#define MaxItems 5 // Maximum items a producer can produce or a
consumer can consume
#define BufferSize 5 // Size of the buffer
sem_t empty;
sem_t full;
int in = 0;
int out = 0;
int buffer[BufferSize];
pthread_mutex_t mutex;
void *producer(void *pno)
{
int item;
for(int i = 0; i < MaxItems; i++) {
Department of Information Technology Page 73 of 125
item = rand(); // Produce an random item
sem_wait(&empty);
pthread_mutex_lock(&mutex);
buffer[in] = item;
printf("Producer %d: Insert Item %d at %d\n", *((int *)pno),buffer[in],in);
in = (in+1)%BufferSize;
pthread_mutex_unlock(&mutex);
sem_post(&full);
}
}
void *consumer(void *cno)
{
for(int i = 0; i < MaxItems; i++) {
sem_wait(&full);
pthread_mutex_lock(&mutex);
int item = buffer[out];
printf("Consumer %d: Remove Item %d from %d\n",*((int *)cno),item,
out);
}
out = (out+1)%BufferSize;
pthread_mutex_unlock(&mutex);
sem_post(&empty);
}
int main()
{
pthread_t pro[5],con[5];
pthread_mutex_init(&mutex, NULL);
sem_init(&empty,0,BufferSize);
Department of Information Technology Page 74 of 125
sem_init(&full,0,0);
int a[5] = {1,2,3,4,5}; //Just used for numbering the producer and
consumer
for(int i = 0; i < 5; i++) {
pthread_create(&pro[i], NULL, (void *)producer, (void *)&a[i]);
}
for(int i = 0; i < 5; i++) {
pthread_create(&con[i], NULL, (void *)consumer, (void *)&a[i]);
}
for(int i = 0; i < 5; i++) {
pthread_join(pro[i], NULL);
}
for(int i = 0; i < 5; i++) {
pthread_join(con[i], NULL);
}
pthread_mutex_destroy(&mutex);
sem_destroy(&empty);
sem_destroy(&full);
return 0;
}

                                        ASSIGNMENT:4B

#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>

sem_t wrt;
pthread_mutex_t mutex;
int cnt = 1;
int numreader = 0;
void *writer(void *wno)
{
sem_wait(&wrt);
cnt = cnt*2;
printf("Writer %d modified cnt to %d\n",(*((int *)wno)),cnt);
sem_post(&wrt);
}
void *reader(void *rno)
{
// Reader acquire the lock before modifying numreader
pthread_mutex_lock(&mutex);
numreader++;
if(numreader == 1) {
sem_wait(&wrt); // If this id the first reader, then it will block the writer
}
pthread_mutex_unlock(&mutex);
// Reading Section
printf("Reader %d: read cnt as %d\n",*((int *)rno),cnt);
// Reader acquire the lock before modifying numreader
pthread_mutex_lock(&mutex);
numreader--;
if(numreader == 0) {
sem_post(&wrt); // If this is the last reader, it will wake up the writer.

}
pthread_mutex_unlock(&mutex);
}
int main()
{
pthread_t read[10],write[5];
pthread_mutex_init(&mutex, NULL);
sem_init(&wrt,0,1);
int a[10] = {1,2,3,4,5,6,7,8,9,10}; //Just used for numbering the
for(int i = 0; i < 10; i++) {
pthread_create(&read[i], NULL, (void *)reader, (void *)&a[i]);
}
for(int i = 0; i < 5; i++) {
pthread_create(&write[i], NULL, (void *)writer, (void *)&a[i]);
}
for(int i = 0; i < 10; i++) {
pthread_join(read[i], NULL);
}
for(int i = 0; i < 5; i++) {
pthread_join(write[i], NULL);
}
pthread_mutex_destroy(&mutex);
sem_destroy(&wrt);
return 0;
}
                                            ASSIGNMENT:5

// Banker's Algorithm
#include <stdio.h>
int main()
{
	// P0, P1, P2, P3, P4 are the Process names here

	int n, m, i, j, k;
	n = 5; // Number of processes
	m = 3; // Number of resources
	int alloc[5][3] = { { 0, 1, 0 }, // P0 // Allocation Matrix
						{ 2, 0, 0 }, // P1
						{ 3, 0, 2 }, // P2
						{ 2, 1, 1 }, // P3
						{ 0, 0, 2 } }; // P4

	int max[5][3] = { { 7, 5, 3 }, // P0 // MAX Matrix
					{ 3, 2, 2 }, // P1
					{ 9, 0, 2 }, // P2
					{ 2, 2, 2 }, // P3
					{ 4, 3, 3 } }; // P4

	int avail[3] = { 3, 3, 2 }; // Available Resources

	int f[n], ans[n], ind = 0;
	for (k = 0; k < n; k++) {
		f[k] = 0;
	}
	int need[n][m];
	for (i = 0; i < n; i++) {
		for (j = 0; j < m; j++)
			need[i][j] = max[i][j] - alloc[i][j];
	}
	int y = 0;
	for (k = 0; k < 5; k++) {
		for (i = 0; i < n; i++) {
			if (f[i] == 0) {

				int flag = 0;
				for (j = 0; j < m; j++) {
					if (need[i][j] > avail[j]){
						flag = 1;
						break;
					}
				}

				if (flag == 0) {
					ans[ind++] = i;
					for (y = 0; y < m; y++)
						avail[y] += alloc[i][y];
					f[i] = 1;
				}
			}
		}
	}

	int flag = 1;
	
	for(int i=0;i<n;i++)
	{
	if(f[i]==0)
	{
		flag=0;
		printf("The following system is not safe");
		break;
	}
	}
	
	if(flag==1)
	{
	printf("Following is the SAFE Sequence\n");
	for (i = 0; i < n - 1; i++)
		printf(" P%d ->", ans[i]);
	printf(" P%d", ans[n - 1]);
	}
	

	return (0);

	// This code is contributed by Deep Baldha (CandyZack)
}


                                              ASSIGNMENT:6

#include<stdio.h>

int main()
{
    int i,j,n,a[50],frame[10],no,k,avail,count=0;
    printf("\nEnter the number of pages:\n");
    scanf("%d",&n);
     printf("\nEnter the page number:\n");
     for (i=0;i<no;i++)
     scanf("%d",&no);
     for(i=0;i<no;i++)
     frame[i]=-1;
     j=0;
     printf("\t ref string \t page frames\n");
     for(i=0;i<=n;i++)
     {
        printf("%d\t\t",a[i]);
        avail=0;
        for(k=0;k<no;k++)
        if(frame[k]==a[i])
        avail=1;
        if(avail==0)
        {
            frame[j]=a[i];
            j=(j+1)%no;
            count++;
            for(k=0;k<no;k++)
            printf("%d\t",frame[k]);
        }
        printf("\n");
     }
     printf("page fault is %d",count);
     return 0;

}

